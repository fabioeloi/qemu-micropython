# Makefile for host-based C unit tests using Unity and CMock

.PHONY: all clean run_tests generate_mocks

# Compiler and common flags
CC = gcc
CFLAGS_COMMON = -std=c11 -Wall -Wextra -g
UNITY_FRAMEWORK_PATH = ../frameworks/unity
# Include path for Unity headers
CFLAGS += -I$(UNITY_FRAMEWORK_PATH)
# Include path for source files under test (assuming they are in ../../src)
CFLAGS += -I../../src
# Include path for any other project headers (e.g. from config)
# CFLAGS += -I../../config # Example if needed

# Unity framework source file
UNITY_SRC = $(UNITY_FRAMEWORK_PATH)/unity.c

# CMock Configuration
# Assumes 'cmock' gem is installed and in PATH.
# If CMock is vendored, adjust CMOCK_CMD (e.g., ruby path/to/cmock.rb)
CMOCK_CMD = cmock
MOCKS_SUBDIR = mocks
MOCKS_BUILD_DIR = ./build # Base directory for build artifacts, including mocks
MOCKS_OUTPUT_DIR = $(MOCKS_BUILD_DIR)/$(MOCKS_SUBDIR) # e.g., ./build/mocks
CMOCK_ARGS = # Add global CMock arguments if needed, e.g., --plugins=ignore,callback

# Add MOCKS_OUTPUT_DIR to include paths for compiling tests that use mock headers
CFLAGS += -I$(MOCKS_OUTPUT_DIR)

# List of header files (relative to project root, e.g., src/module/header.h)
# that need mocks to be generated.
HEADERS_TO_MOCK = \
    src/peripherals/sensor_reader.h \
    # Add other headers here: e.g., src/another_module/interface.h

# Generate mock .c file paths based on MOCKS_OUTPUT_DIR and original header name
# e.g., src/peripherals/sensor_reader.h -> build/mocks/mock_sensor_reader.c
MOCK_C_FILES = $(patsubst src/%.h,$(MOCKS_OUTPUT_DIR)/mock_%.c,$(HEADERS_TO_MOCK))


# Target to generate all mocks explicitly if needed, also serves as a prerequisite.
generate_mocks: $(MOCKS_C_FILES)

# Rule to create the mocks output directory (and its parent build/ directory)
$(MOCKS_OUTPUT_DIR):
	@echo "Creating mocks directory: $(MOCKS_OUTPUT_DIR)"
	mkdir -p $(MOCKS_OUTPUT_DIR)

# Pattern rule to generate a specific mock_%.c file from its original src/%.h file
# The mock .c file (and its .h) will be placed in $(MOCKS_OUTPUT_DIR).
$(MOCKS_OUTPUT_DIR)/mock_%.c: ../../src/%.h | $(MOCKS_OUTPUT_DIR)
	@echo "CMock: Generating mock for $< -> $(MOCKS_OUTPUT_DIR)/mock_$(basename $(notdir $<)).c/h"
	$(CMOCK_CMD) $(CMOCK_ARGS) $< --mock_path=$(MOCKS_OUTPUT_DIR)


# List of test suite base names (e.g., string_utils, data_processor)
TEST_SUITES = string_utils
TEST_SUITES += data_processor

TEST_EXECUTABLES = $(foreach suite,$(TEST_SUITES),test_$(suite).out)

all: generate_mocks $(TEST_EXECUTABLES) # Ensure mocks are generated before executables

# Define sources under test for each suite (from project's src/ directory)
SRC_string_utils = ../../src/utils/string_utils.c
SRC_data_processor = ../../src/processing/data_processor.c

# Define which generated MOCK .c files each test suite needs to link against.
# If a suite needs no mocks, this variable can be empty or undefined for it.
MOCKS_FOR_string_utils = # string_utils tests don't need mocks for this example
MOCKS_FOR_data_processor = $(MOCKS_OUTPUT_DIR)/mock_sensor_reader.c


# Rule to build each test executable
# %.out depends on its runner, its test cases, Unity, its specific SUT .c files, and its specific mock .c files.
# The specific mock .c files (e.g., $(MOCKS_OUTPUT_DIR)/mock_sensor_reader.c) must have been generated by the
# pattern rule for mock generation, triggered by being listed in MOCKS_FOR_xxx.
$(TEST_EXECUTABLES): %.out: test_%.runner.c test_%.c $(UNITY_SRC) $($(MOCKS_FOR_$(basename $(patsubst test_%,%,$@))))
	@echo "Building test executable $@ ..."
	$(CC) $(CFLAGS) \
		test_$(basename $(patsubst test_%,%,$@)).runner.c \
		test_$(basename $(patsubst test_%,%,$@)).c \
		$(UNITY_SRC) \
		$(SRC_$(basename $(patsubst test_%,%,$@))) \
		$($(MOCKS_FOR_$(basename $(patsubst test_%,%,$@)))) \
		-o $@
	@echo "$@ built successfully."


# Target to run all built test executables
run_tests: $(TEST_EXECUTABLES)
	@echo ""
	@echo "Running all C host unit tests..."
	@echo "=================================="
	@passed_all=true; \
	for test_exe in $(TEST_EXECUTABLES); do \
		echo ""; \
		echo "--- Running $$test_exe ---"; \
		./$$test_exe; \
		if [ $$? -ne 0 ]; then \
			echo "!!! TEST SUITE $$test_exe FAILED !!!"; \
			passed_all=false; \
		else \
			echo "--- TEST SUITE $$test_exe PASSED ---"; \
		fi; \
	done; \
	echo ""; \
	echo "=================================="; \
	if $$passed_all; then \
		echo "All C host test suites PASSED."; \
	else \
		echo "SOME C HOST TEST SUITES FAILED."; \
		exit 1; \
	fi

# Clean up build artifacts
clean:
	@echo "Cleaning host test build artifacts..."
	rm -f $(TEST_EXECUTABLES) *.o
	rm -rf $(MOCKS_BUILD_DIR) # Clean entire mock build structure (build/mocks and build itself if only for mocks)
	rm -rf *.dSYM # macOS debug symbols
	@echo "Done."
